name: Bounty Cleanup and Maintenance

on:
  schedule:
    # Runs weekly on Sunday at 2am UTC
    - cron: "0 2 * * 0"
  workflow_dispatch:

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up bounty labels and state
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const BOUNTY_LABEL = 'bounty';
            const QUEUE_LABEL = 'has-queue';
            const PROGRESS_LABELS = ['in-progress', 'in-review', 'stale-assignee'];

            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: BOUNTY_LABEL,
              per_page: 100
            });

            let cleanupCount = 0;

            for (const issue of issues.data) {
              const labels = issue.labels.map(l => l.name);
              const hasAssignee = issue.assignees && issue.assignees.length > 0;
              
              // Remove progress labels from unassigned issues
              if (!hasAssignee) {
                for (const label of PROGRESS_LABELS) {
                  if (labels.includes(label)) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: label
                      });
                      cleanupCount++;
                    } catch (e) {}
                  }
                }
              }
              
              // Check if has-queue label is still valid
              if (labels.includes(QUEUE_LABEL)) {
                const comments = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  per_page: 100
                });
                
                const currentAssignee = issue.assignees?.[0]?.login;
                
                // Check for queue requests
                const assignmentKeywords = [
                  'i would like to work on this',
                  'i\'d like to work on this',
                  'can i work on this',
                  'please assign me',
                  'assign me',
                  'i\'ll take this',
                  'i\'d like to take this',
                  'i\'m interested',
                  'interested in working'
                ];
                
                const queueRequests = comments.data.filter(c => {
                  if (c.user.login === currentAssignee) return false;
                  if (c.user.type === 'Bot') return false;
                  const cLower = c.body.toLowerCase();
                  return assignmentKeywords.some(k => cLower.includes(k));
                });
                
                const uniqueRequesters = [...new Set(queueRequests.map(c => c.user.login))];
                
                // Remove has-queue if no valid queue exists or issue is unassigned
                if (uniqueRequesters.length === 0 || !hasAssignee) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      name: QUEUE_LABEL
                    });
                    cleanupCount++;
                  } catch (e) {}
                }
              }
              
              // Check for orphaned PRs (linked but PR is closed/merged)
              if (labels.some(l => l === 'in-review' || l === 'in-progress')) {
                const timeline = await github.rest.issues.listEventsForTimeline({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  per_page: 100
                });
                
                const crossRefs = timeline.data.filter(e => 
                  e.event === 'cross-referenced' && e.source?.issue?.pull_request
                );
                
                // Check if all linked PRs are closed
                let hasOpenPR = false;
                for (const ref of crossRefs) {
                  const prNumber = ref.source.issue.number;
                  try {
                    const { data: pr } = await github.rest.pulls.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    if (pr.state === 'open') {
                      hasOpenPR = true;
                      break;
                    }
                  } catch (e) {}
                }
                
                if (!hasOpenPR && crossRefs.length > 0) {
                  for (const label of ['in-progress', 'in-review']) {
                    if (labels.includes(label)) {
                      try {
                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issue.number,
                          name: label
                        });
                        cleanupCount++;
                      } catch (e) {}
                    }
                  }
                }
              }
            }

            console.log(`Cleanup: ${cleanupCount} changes`);
